#!/usr/bin/env node

/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 118967:
/***/ ((module) => {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = () => ([]);
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = 118967;
module.exports = webpackEmptyContext;

/***/ }),

/***/ 659602:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
  run: __webpack_require__(344556),
  meta: __webpack_require__(399608)
};


/***/ }),

/***/ 399608:
/***/ ((module) => {

module.exports = {
  command: "dashboard",
  description:
    "Start Truffle Dashboard to sign development transactions using browser wallet",
  builder: {
    port: {
      describe: "Specify the port to start the dashboard and RPC endpoint on",
      type: "number"
    },
    host: {
      describe: "Specify the host to start the dashboard and RPC endpoint on",
      type: "string"
    },
    verbose: {
      describe: "Display debug logs for the dashboard server and message bus",
      type: "boolean"
    }
  },
  help: {
    usage: "truffle dashboard [--port <number>] [--host <string>] [--verbose]",
    options: [
      {
        option: "--port <number>",
        description: "Start the dashboard and RPC endpoint on a specific port."
      },
      {
        option: "--host <string>",
        description: "Start the dashboard and RPC endpoint on a specific host."
      },
      {
        option: "--verbose",
        description:
          "Log debug information from the Dashboard server and message bus."
      }
    ],
    allowedGlobalOptions: []
  }
};


/***/ }),

/***/ 344556:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = async function (options) {
  const { detectConfigOrDefault } = __webpack_require__(54708);
  const { DashboardServer } = __webpack_require__(897722);
  const address = __webpack_require__(494849);

  const config = detectConfigOrDefault(options);

  const port = options.port || config.dashboard.port;
  const host = options.host || config.dashboard.host;
  const verbose = options.verbose || config.dashboard.verbose;
  const rpc = true;

  const dashboardServerOptions = { port, host, verbose, rpc };
  const dashboardServer = new DashboardServer(dashboardServerOptions);
  await dashboardServer.start();

  if (host === "0.0.0.0") {
    // Regex taken from react-scripts to check that the address is a private IP, otherwise we discard it
    // https://en.wikipedia.org/wiki/Private_network#Private_IPv4_address_spaces
    let lanAddress =
      /^10[.]|^172[.](1[6-9]|2[0-9]|3[0-1])[.]|^192[.]168[.]/.test(address.ip())
        ? address.ip()
        : undefined;

    console.log(`Truffle Dashboard running at http://localhost:${port}`);
    lanAddress &&
      console.log(`                             http://${lanAddress}:${port}`);

    console.log(
      `DashboardProvider RPC endpoint running at http://localhost:${port}/rpc`
    );
    lanAddress &&
      console.log(
        `                                          http://${lanAddress}:${port}/rpc`
      );
  } else {
    console.log(`Truffle Dashboard running at http://${host}:${port}`);
    console.log(
      `DashboardProvider RPC endpoint running at http://${host}:${port}/rpc`
    );
  }

  // ensure that `await`-ing this method never resolves. (we want to keep
  // the console open until it exits on its own)
  return new Promise(() => {});
};


/***/ }),

/***/ 54708:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Extracts the input flags --option from the arguments  of type `--option=value` or `--option value` or `--flag`
const extractFlags = inputArguments => {
  // Get all the args that begins with `--`. This also includes `--option=value`
  const inputFlags = inputArguments.filter(flag => {
    return flag.startsWith("--") ? flag : null;
  });

  // Extract only the flags i.e `--option` from `--option=value`
  inputFlags.map((flag, i) => {
    let indexOfEqualsSign = flag.indexOf("=");
    if (indexOfEqualsSign > 0) {
      flag = flag.slice(0, indexOfEqualsSign);
      inputFlags.splice(i, 1, flag);
    }
  });
  return inputFlags;
};

const detectConfigOrDefault = options => {
  const Config = __webpack_require__(120553);

  try {
    return Config.detect(options);
  } catch (error) {
    // Suppress error when truffle can't find a config
    if (error.message === "Could not find suitable configuration file.") {
      return Config.default();
    } else {
      throw error;
    }
  }
};

module.exports = { extractFlags, detectConfigOrDefault };


/***/ }),

/***/ 396524:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DashboardMessageBus = void 0;
const delay_1 = __importDefault(__webpack_require__(465780));
const events_1 = __webpack_require__(582361);
const utils_1 = __webpack_require__(944794);
const util_1 = __webpack_require__(473837);
class DashboardMessageBus extends events_1.EventEmitter {
    constructor(publishPort, subscribePort, host = "localhost") {
        super();
        this.publishPort = publishPort;
        this.subscribePort = subscribePort;
        this.host = host;
        this.publishers = [];
        this.subscribers = [];
        this.unfulfilledRequests = new Map([]);
    }
    /**
     * Start the DashboardMessageBus
     * @dev This starts separate websocket servers for subscribers/publishers
     */
    start() {
        return __awaiter(this, void 0, void 0, function* () {
            this.subscribeServer = yield utils_1.startWebSocketServer({
                host: this.host,
                port: this.subscribePort
            });
            this.subscribeServer.on("connection", (newSubscriber) => {
                newSubscriber.on("close", () => {
                    this.removeSubscriber(newSubscriber);
                });
                // Require the subscriber to send a message *first* before being added
                newSubscriber.once("message", () => this.addSubscriber(newSubscriber));
            });
            this.publishServer = yield utils_1.startWebSocketServer({
                host: this.host,
                port: this.publishPort
            });
            this.publishServer.on("connection", (newPublisher) => {
                newPublisher.on("close", () => {
                    this.removePublisher(newPublisher);
                });
                this.addPublisher(newPublisher);
            });
        });
    }
    /**
     * Wait for the message bus to be "ready" to process requests (i.e. having any subscribers).
     * @dev Polls every second to see if the number of subscribers > 0
     */
    ready() {
        return __awaiter(this, void 0, void 0, function* () {
            while (this.subscribers.length === 0) {
                yield delay_1.default(1000);
            }
        });
    }
    /**
     * Close both websocket servers
     * @dev Emits a "terminate" event
     */
    terminate() {
        return __awaiter(this, void 0, void 0, function* () {
            yield util_1.promisify(this.publishServer.close.bind(this.publishServer))();
            yield util_1.promisify(this.subscribeServer.close.bind(this.subscribeServer))();
            this.emit("terminate");
        });
    }
    /**
     * Process a message `data` coming from `publisher` by sending it to `subscribers`
     * and return the first received response to the `publisher`
     */
    processRequest(publisher, data, subscribers) {
        return __awaiter(this, void 0, void 0, function* () {
            // convert to string for uniformity since WebSocket.Data can take other forms
            if (typeof data !== "string") {
                data = data.toString();
            }
            yield this.ready();
            this.unfulfilledRequests.set(data, { publisher, data });
            const message = utils_1.base64ToJson(data);
            try {
                this.logToPublishers(`Sending message to ${subscribers.length} subscribers`, "requests");
                this.logToPublishers(message, "requests");
                const response = yield utils_1.broadcastAndAwaitFirst(subscribers, message);
                this.logToPublishers(`Sending response for message ${message.id}`, "responses");
                this.logToPublishers(response, "responses");
                const encodedResponse = utils_1.jsonToBase64(response);
                publisher.send(encodedResponse);
                this.unfulfilledRequests.delete(data);
                this.invalidateMessage(message.id);
            }
            catch (error) {
                this.logToPublishers(`An error occurred while processing message ${message.id}`, "errors");
                this.logToPublishers(error, "errors");
            }
        });
    }
    invalidateMessage(id) {
        const invalidationMessage = utils_1.createMessage("invalidate", id);
        utils_1.broadcastAndDisregard(this.subscribers, invalidationMessage);
    }
    logToPublishers(logMessage, namespace) {
        this.logTo(logMessage, this.publishers, namespace);
    }
    logToSubscribers(logMessage, namespace) {
        this.logTo(logMessage, this.subscribers, namespace);
    }
    logToAll(logMessage, namespace) {
        this.logToPublishers(logMessage, namespace);
        this.logToSubscribers(logMessage, namespace);
    }
    logTo(logMessage, receivers, namespace) {
        const payload = {
            namespace: "dashboard-message-bus",
            message: logMessage
        };
        if (namespace) {
            payload.namespace += `:${namespace}`;
        }
        const message = utils_1.createMessage("log", payload);
        utils_1.broadcastAndDisregard(receivers, message);
    }
    /**
     * Add a publisher so it can be used to send requests to
     * @dev Also sends all backlogged (unfulfilled) requests upon connection
     */
    addSubscriber(newSubscriber) {
        this.unfulfilledRequests.forEach(({ publisher, data }) => this.processRequest(publisher, data, [newSubscriber]));
        this.logToPublishers("Subscriber connected", "connections");
        this.subscribers.push(newSubscriber);
    }
    /**
     * Remove a subscriber
     * @dev Will cause the server to terminate if this was the last connection
     */
    removeSubscriber(subscriberToRemove) {
        this.logToPublishers("Subscriber disconnected", "connections");
        this.subscribers = this.subscribers.filter(subscriber => subscriber !== subscriberToRemove);
        this.terminateIfNoConnections();
    }
    /**
     * Add a publisher and set up message listeners to process their requests
     */
    addPublisher(newPublisher) {
        this.logToPublishers("Publisher connected", "connections");
        newPublisher.on("message", (data) => {
            this.processRequest(newPublisher, data, this.subscribers);
        });
        this.publishers.push(newPublisher);
    }
    /**
     * Remove a publisher and their corresponding requests
     * @dev Will cause the server to terminate if this was the last connection
     */
    removePublisher(publisherToRemove) {
        this.logToPublishers("Publisher disconnected", "connections");
        this.publishers = this.publishers.filter(publisher => publisher !== publisherToRemove);
        this.clearRequestsForPublisher(publisherToRemove);
        this.terminateIfNoConnections();
    }
    terminateIfNoConnections() {
        if (this.publishers.length === 0 && this.subscribers.length === 0) {
            this.terminate();
        }
    }
    clearRequestsForPublisher(publisher) {
        this.unfulfilledRequests.forEach(({ publisher: requestPublisher }, key) => {
            if (requestPublisher === publisher) {
                this.unfulfilledRequests.delete(key);
            }
        });
    }
}
exports.DashboardMessageBus = DashboardMessageBus;
//# sourceMappingURL=DashboardMessageBus.js.map

/***/ }),

/***/ 737108:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(396524), exports);
__exportStar(__webpack_require__(944794), exports);
__exportStar(__webpack_require__(136167), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 431482:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isInvalidateMessage = exports.isLogMessage = exports.isDashboardProviderMessage = void 0;
const isDashboardProviderMessage = (message) => {
    return message.type === "provider";
};
exports.isDashboardProviderMessage = isDashboardProviderMessage;
const isLogMessage = (message) => {
    return message.type === "log";
};
exports.isLogMessage = isLogMessage;
const isInvalidateMessage = (message) => {
    return message.type === "invalidate";
};
exports.isInvalidateMessage = isInvalidateMessage;
//# sourceMappingURL=types.js.map

/***/ }),

/***/ 136167:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(431482), exports);
//# sourceMappingURL=types.js.map

/***/ }),

/***/ 944794:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getMessageBusPorts = exports.connectToMessageBus = exports.connectToMessageBusWithRetries = exports.sendAndAwait = exports.broadcastAndAwaitFirst = exports.broadcastAndDisregard = exports.createMessage = exports.startWebSocketServer = exports.base64ToJson = exports.jsonToBase64 = void 0;
const isomorphic_ws_1 = __importDefault(__webpack_require__(347030));
const promise_any_1 = __importDefault(__webpack_require__(625795));
const delay_1 = __importDefault(__webpack_require__(465780));
const axios_1 = __importDefault(__webpack_require__(409669));
promise_any_1.default.shim();
/**
 * Convert any JS object or value to a base64 representation of it
 */
const jsonToBase64 = (json) => {
    const stringifiedJson = JSON.stringify(json);
    const buffer = Buffer.from(stringifiedJson);
    const base64 = buffer.toString("base64");
    return base64;
};
exports.jsonToBase64 = jsonToBase64;
/**
 * Convert the base64 representation of a JS object or value to its JS representation
 * @dev This is the reverse of `jsonToBase64` and is not expected to work with other base64 formats
 */
const base64ToJson = (base64) => {
    const buffer = Buffer.from(base64, "base64");
    const stringifiedJson = buffer.toString("utf8");
    const json = JSON.parse(stringifiedJson);
    return json;
};
exports.base64ToJson = base64ToJson;
/**
 * Starts a websocket server and waits for it to be opened
 * @dev If you need to attach event listeners *before* the server connection opens,
 * do not use this function since it resolves *after* the connection is opened
 */
const startWebSocketServer = (options) => {
    return new Promise(resolve => {
        const server = new isomorphic_ws_1.default.Server(options, () => resolve(server));
    });
};
exports.startWebSocketServer = startWebSocketServer;
const createMessage = (type, payload) => {
    const id = Math.random();
    return { id, type, payload };
};
exports.createMessage = createMessage;
/**
 * Broadcast a message to multiple websocket connections and disregard them
 */
const broadcastAndDisregard = (sockets, message) => {
    const encodedMessage = exports.jsonToBase64(message);
    sockets.forEach(socket => {
        socket.send(encodedMessage);
    });
};
exports.broadcastAndDisregard = broadcastAndDisregard;
/**
 * Broadcast a message to multuple websocket connections and return the first response
 */
const broadcastAndAwaitFirst = (sockets, message) => __awaiter(void 0, void 0, void 0, function* () {
    const promises = sockets.map(socket => exports.sendAndAwait(socket, message));
    const result = yield Promise.any(promises);
    return result;
});
exports.broadcastAndAwaitFirst = broadcastAndAwaitFirst;
/**
 * Send a message to a websocket connection and await a matching response
 * @dev Responses are matched by looking at received messages that match the ID of the sent message
 */
const sendAndAwait = (socket, message) => {
    return new Promise((resolve, reject) => {
        socket.addEventListener("message", (event) => {
            if (typeof event.data !== "string") {
                event.data = event.data.toString();
            }
            const response = exports.base64ToJson(event.data);
            if (response.id !== message.id)
                return;
            resolve(response);
        });
        // TODO: Need to check that the error corresponds to the sent message?
        socket.addEventListener("error", (event) => {
            reject(event.error);
        });
        socket.addEventListener("close", (event) => {
            reject(new Error(`Socket connection closed with code '${event.code}' and reason '${event.reason}'`));
        });
        const encodedMessage = exports.jsonToBase64(message);
        socket.send(encodedMessage);
    });
};
exports.sendAndAwait = sendAndAwait;
const connectToMessageBusWithRetries = (port, host = "localhost", retries = 50) => __awaiter(void 0, void 0, void 0, function* () {
    let error = new Error();
    for (let tryCount = 0; tryCount < retries; tryCount += 1) {
        try {
            return yield exports.connectToMessageBus(port, host);
        }
        catch (e) {
            error = e;
            yield delay_1.default(1000);
        }
    }
    throw error;
});
exports.connectToMessageBusWithRetries = connectToMessageBusWithRetries;
const connectToMessageBus = (port, host = "localhost") => {
    const socket = new isomorphic_ws_1.default(`ws://${host}:${port}`);
    return new Promise((resolve, reject) => {
        socket.addEventListener("open", () => resolve(socket));
        socket.addEventListener("error", (event) => reject(event.error));
    });
};
exports.connectToMessageBus = connectToMessageBus;
const getMessageBusPorts = (dashboardPort, dashboardHost = "localhost", retries = 5) => __awaiter(void 0, void 0, void 0, function* () {
    for (let tryCount = 0; tryCount < retries; tryCount += 1) {
        try {
            const { data } = yield axios_1.default.get(`http://${dashboardHost}:${dashboardPort}/ports`);
            return data;
        }
        catch (e) {
            yield delay_1.default(1000);
        }
    }
    throw new Error(`Could not connect to dashboard at http://${dashboardHost}:${dashboardPort}/ports`);
});
exports.getMessageBusPorts = getMessageBusPorts;
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ 866205:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DashboardServer = void 0;
const express_1 = __importDefault(__webpack_require__(999268));
const path_1 = __importDefault(__webpack_require__(371017));
const get_port_1 = __importDefault(__webpack_require__(715959));
const open_1 = __importDefault(__webpack_require__(678318));
const dashboard_message_bus_1 = __webpack_require__(737108);
const cors_1 = __importDefault(__webpack_require__(917846));
const debug_1 = __importDefault(__webpack_require__(791258));
class DashboardServer {
    constructor(options) {
        var _a, _b, _c, _d;
        this.port = options.port;
        this.host = (_a = options.host) !== null && _a !== void 0 ? _a : "localhost";
        this.rpc = (_b = options.rpc) !== null && _b !== void 0 ? _b : true;
        this.verbose = (_c = options.verbose) !== null && _c !== void 0 ? _c : false;
        this.autoOpen = (_d = options.autoOpen) !== null && _d !== void 0 ? _d : true;
        this.frontendPath = path_1.default.join(__dirname, ".", "dashboard-frontend", "build");
        this.boundTerminateListener = () => this.stop();
    }
    start() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if ((_a = this.httpServer) === null || _a === void 0 ? void 0 : _a.listening)
                return;
            this.messageBus = yield this.startMessageBus();
            this.expressApp = express_1.default();
            this.expressApp.use(cors_1.default());
            this.expressApp.use(express_1.default.json());
            this.expressApp.use(express_1.default.static(this.frontendPath));
            this.expressApp.get("/ports", this.getPorts.bind(this));
            if (this.rpc) {
                this.socket = yield this.connectToMessageBus();
                this.expressApp.post("/rpc", this.postRpc.bind(this));
            }
            yield new Promise(resolve => {
                this.httpServer = this.expressApp.listen(this.port, this.host, () => {
                    if (this.autoOpen) {
                        const host = this.host === "0.0.0.0" ? "localhost" : this.host;
                        open_1.default(`http://${host}:${this.port}`);
                    }
                    resolve();
                });
            });
        });
    }
    stop() {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            (_a = this.messageBus) === null || _a === void 0 ? void 0 : _a.off("terminate", this.boundTerminateListener);
            yield ((_b = this.messageBus) === null || _b === void 0 ? void 0 : _b.terminate());
            (_c = this.socket) === null || _c === void 0 ? void 0 : _c.terminate();
            return new Promise(resolve => {
                var _a;
                (_a = this.httpServer) === null || _a === void 0 ? void 0 : _a.close(() => resolve());
            });
        });
    }
    getPorts(req, res) {
        if (!this.messageBus) {
            throw new Error("Message bus has not been started yet");
        }
        res.json({
            dashboardPort: this.port,
            subscribePort: this.messageBus.subscribePort,
            publishPort: this.messageBus.publishPort
        });
    }
    postRpc(req, res, next) {
        if (!this.socket) {
            throw new Error("Not connected to message bus");
        }
        const message = dashboard_message_bus_1.createMessage("provider", req.body);
        dashboard_message_bus_1.sendAndAwait(this.socket, message)
            .then(response => res.json(response.payload))
            .catch(next);
    }
    startMessageBus() {
        return __awaiter(this, void 0, void 0, function* () {
            const messageBusPublishPort = yield get_port_1.default({ host: this.host });
            const messageBusSubscribePort = yield get_port_1.default({ host: this.host });
            const messageBus = new dashboard_message_bus_1.DashboardMessageBus(messageBusPublishPort, messageBusSubscribePort, this.host);
            yield messageBus.start();
            messageBus.on("terminate", this.boundTerminateListener);
            return messageBus;
        });
    }
    connectToMessageBus() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.messageBus) {
                throw new Error("Message bus has not been started yet");
            }
            const socket = yield dashboard_message_bus_1.connectToMessageBusWithRetries(this.messageBus.publishPort, this.host);
            if (this.verbose) {
                socket.addEventListener("message", (event) => {
                    if (typeof event.data !== "string") {
                        event.data = event.data.toString();
                    }
                    const message = dashboard_message_bus_1.base64ToJson(event.data);
                    if (message.type === "log") {
                        const logMessage = message;
                        const debug = debug_1.default(logMessage.payload.namespace);
                        debug.enabled = true;
                        debug(logMessage.payload.message);
                    }
                });
            }
            return socket;
        });
    }
}
exports.DashboardServer = DashboardServer;
//# sourceMappingURL=DashboardServer.js.map

/***/ }),

/***/ 897722:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(866205), exports);
__exportStar(__webpack_require__(732550), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 732550:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.startDashboardInBackground = void 0;
const dashboard_message_bus_1 = __webpack_require__(737108);
const child_process_1 = __webpack_require__(532081);
const path_1 = __importDefault(__webpack_require__(371017));
const startDashboardInBackground = (options) => {
    const dashboardPath = path_1.default.join(__dirname, "..", "bin", "start-dashboard");
    const optionsBase64 = dashboard_message_bus_1.jsonToBase64(options);
    const child = child_process_1.spawn("node", [dashboardPath, optionsBase64], {
        detached: true,
        stdio: "ignore"
    });
    return child;
};
exports.startDashboardInBackground = startDashboardInBackground;
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ 344516:
/***/ ((module) => {

"use strict";
module.exports = require("original-require");

/***/ }),

/***/ 439491:
/***/ ((module) => {

"use strict";
module.exports = require("assert");

/***/ }),

/***/ 950852:
/***/ ((module) => {

"use strict";
module.exports = require("async_hooks");

/***/ }),

/***/ 714300:
/***/ ((module) => {

"use strict";
module.exports = require("buffer");

/***/ }),

/***/ 532081:
/***/ ((module) => {

"use strict";
module.exports = require("child_process");

/***/ }),

/***/ 722057:
/***/ ((module) => {

"use strict";
module.exports = require("constants");

/***/ }),

/***/ 706113:
/***/ ((module) => {

"use strict";
module.exports = require("crypto");

/***/ }),

/***/ 582361:
/***/ ((module) => {

"use strict";
module.exports = require("events");

/***/ }),

/***/ 657147:
/***/ ((module) => {

"use strict";
module.exports = require("fs");

/***/ }),

/***/ 113685:
/***/ ((module) => {

"use strict";
module.exports = require("http");

/***/ }),

/***/ 795687:
/***/ ((module) => {

"use strict";
module.exports = require("https");

/***/ }),

/***/ 498188:
/***/ ((module) => {

"use strict";
module.exports = require("module");

/***/ }),

/***/ 241808:
/***/ ((module) => {

"use strict";
module.exports = require("net");

/***/ }),

/***/ 822037:
/***/ ((module) => {

"use strict";
module.exports = require("os");

/***/ }),

/***/ 371017:
/***/ ((module) => {

"use strict";
module.exports = require("path");

/***/ }),

/***/ 285477:
/***/ ((module) => {

"use strict";
module.exports = require("punycode");

/***/ }),

/***/ 863477:
/***/ ((module) => {

"use strict";
module.exports = require("querystring");

/***/ }),

/***/ 514521:
/***/ ((module) => {

"use strict";
module.exports = require("readline");

/***/ }),

/***/ 12781:
/***/ ((module) => {

"use strict";
module.exports = require("stream");

/***/ }),

/***/ 371576:
/***/ ((module) => {

"use strict";
module.exports = require("string_decoder");

/***/ }),

/***/ 924404:
/***/ ((module) => {

"use strict";
module.exports = require("tls");

/***/ }),

/***/ 76224:
/***/ ((module) => {

"use strict";
module.exports = require("tty");

/***/ }),

/***/ 257310:
/***/ ((module) => {

"use strict";
module.exports = require("url");

/***/ }),

/***/ 473837:
/***/ ((module) => {

"use strict";
module.exports = require("util");

/***/ }),

/***/ 626144:
/***/ ((module) => {

"use strict";
module.exports = require("vm");

/***/ }),

/***/ 959796:
/***/ ((module) => {

"use strict";
module.exports = require("zlib");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = __webpack_module_cache__;
/******/ 	
/******/ 	// the startup function
/******/ 	__webpack_require__.x = () => {
/******/ 		// Load entry module and return exports
/******/ 		var __webpack_exports__ = __webpack_require__.O(undefined, [5158,6629,9669,4914,8363,553], () => (__webpack_require__(659602)))
/******/ 		__webpack_exports__ = __webpack_require__.O(__webpack_exports__);
/******/ 		return __webpack_exports__;
/******/ 	};
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/amd options */
/******/ 	(() => {
/******/ 		__webpack_require__.amdO = {};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/chunk loaded */
/******/ 	(() => {
/******/ 		var deferred = [];
/******/ 		__webpack_require__.O = (result, chunkIds, fn, priority) => {
/******/ 			if(chunkIds) {
/******/ 				priority = priority || 0;
/******/ 				for(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];
/******/ 				deferred[i] = [chunkIds, fn, priority];
/******/ 				return;
/******/ 			}
/******/ 			var notFulfilled = Infinity;
/******/ 			for (var i = 0; i < deferred.length; i++) {
/******/ 				var [chunkIds, fn, priority] = deferred[i];
/******/ 				var fulfilled = true;
/******/ 				for (var j = 0; j < chunkIds.length; j++) {
/******/ 					if ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {
/******/ 						chunkIds.splice(j--, 1);
/******/ 					} else {
/******/ 						fulfilled = false;
/******/ 						if(priority < notFulfilled) notFulfilled = priority;
/******/ 					}
/******/ 				}
/******/ 				if(fulfilled) {
/******/ 					deferred.splice(i--, 1)
/******/ 					var r = fn();
/******/ 					if (r !== undefined) result = r;
/******/ 				}
/******/ 			}
/******/ 			return result;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/ensure chunk */
/******/ 	(() => {
/******/ 		__webpack_require__.f = {};
/******/ 		// This file contains only the entry chunk.
/******/ 		// The chunk loading function for additional chunks
/******/ 		__webpack_require__.e = (chunkId) => {
/******/ 			return Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {
/******/ 				__webpack_require__.f[key](chunkId, promises);
/******/ 				return promises;
/******/ 			}, []));
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks and sibling chunks for the entrypoint
/******/ 		__webpack_require__.u = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "" + chunkId + ".bundled.js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/require chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded chunks
/******/ 		// "1" means "loaded", otherwise not loaded yet
/******/ 		var installedChunks = {
/******/ 			9966: 1
/******/ 		};
/******/ 		
/******/ 		__webpack_require__.O.require = (chunkId) => (installedChunks[chunkId]);
/******/ 		
/******/ 		var installChunk = (chunk) => {
/******/ 			var moreModules = chunk.modules, chunkIds = chunk.ids, runtime = chunk.runtime;
/******/ 			for(var moduleId in moreModules) {
/******/ 				if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 					__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 				}
/******/ 			}
/******/ 			if(runtime) runtime(__webpack_require__);
/******/ 			for(var i = 0; i < chunkIds.length; i++)
/******/ 				installedChunks[chunkIds[i]] = 1;
/******/ 			__webpack_require__.O();
/******/ 		};
/******/ 		
/******/ 		// require() chunk loading for javascript
/******/ 		__webpack_require__.f.require = (chunkId, promises) => {
/******/ 			// "1" is the signal for "already loaded"
/******/ 			if(!installedChunks[chunkId]) {
/******/ 				if(true) { // all chunks have JS
/******/ 					installChunk(require("./" + __webpack_require__.u(chunkId)));
/******/ 				} else installedChunks[chunkId] = 1;
/******/ 			}
/******/ 		};
/******/ 		
/******/ 		// no external install chunk
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/startup chunk dependencies */
/******/ 	(() => {
/******/ 		var next = __webpack_require__.x;
/******/ 		__webpack_require__.x = () => {
/******/ 			__webpack_require__.e(5158);
/******/ 			__webpack_require__.e(6629);
/******/ 			__webpack_require__.e(9669);
/******/ 			__webpack_require__.e(4914);
/******/ 			__webpack_require__.e(8363);
/******/ 			__webpack_require__.e(553);
/******/ 			return next();
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// module cache are used so entry inlining is disabled
/******/ 	// run startup
/******/ 	var __webpack_exports__ = __webpack_require__.x();
/******/ 	var __webpack_export_target__ = exports;
/******/ 	for(var i in __webpack_exports__) __webpack_export_target__[i] = __webpack_exports__[i];
/******/ 	if(__webpack_exports__.__esModule) Object.defineProperty(__webpack_export_target__, "__esModule", { value: true });
/******/ 	
/******/ })()
;
//# sourceMappingURL=dashboard.bundled.js.map